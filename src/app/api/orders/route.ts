import { NextRequest, NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@/lib/supabase/api'
import { requireAuth, requireAdmin } from '@/lib/supabase/api'
import { orderSchema } from '@/lib/validations/schemas'
import { jsonOk, jsonCreated, jsonError, parsePagination } from '@/lib/api/response'
import { parseOrderFilters } from '@/lib/api/filters'
import type { OrderStatus } from '@/types'

export async function POST(req: NextRequest) {
  try {
    const { user, error } = await requireAdmin(req)
    if (error) return jsonError(error.message, error.status)

    const body = await req.json()
    const parsed = orderSchema.safeParse(body)
    if (!parsed.success) {
      return jsonError(parsed.error.issues.map((i) => i.message).join(', '), 400)
    }

    const supabase = createRouteHandlerClient(req)
    const payload = {
      ...parsed.data,
      status: 'dispatched' as const,
      is_dispatched: true,
      created_by: user!.id,
    }

    // order_number generated by DB trigger if not provided
    const { data, error: insertError } = await supabase
      .from('orders')
      .insert(payload)
      .select('*')
      .single()

    if (insertError) return jsonError(insertError.message, 400)

    return jsonCreated(data, 'Order created successfully')
  } catch (e: any) {
    return jsonError('Failed to create order', 500)
  }
}

export async function GET(req: NextRequest) {
  try {
    const auth = await requireAuth(req)
    if (auth.error) return jsonError(auth.error.message, auth.error.status)
    const current = auth.user!

    const { searchParams } = new URL(req.url)
    const filters = parseOrderFilters(searchParams)
    const { page, per_page, from, to } = parsePagination(searchParams)

    const supabase = createRouteHandlerClient(req)

    let query = supabase
      .from('orders')
      .select('*, driver:users!orders_driver_id_fkey(id,full_name,email)', { count: 'exact' })

    // Role-based access
    if (current.role !== 'admin') {
      query = query.eq('driver_id', current.id)
    }

    // Apply filters
    if (filters.status && filters.status.length > 0) query = query.in('status', filters.status as OrderStatus[])
    if (filters.driver_id) query = query.eq('driver_id', filters.driver_id)
    if (filters.week_number) query = query.eq('week_number', filters.week_number)
    if (filters.start_date) query = query.gte('date', filters.start_date)
    if (filters.end_date) query = query.lte('date', filters.end_date)
    if (filters.search) {
      const s = filters.search.replace(/%/g, '')
      query = query.or(`order_number.ilike.%${s}%,customer_name.ilike.%${s}%,driver_name.ilike.%${s}%`)
    }

    query = query.order('date', { ascending: false }).range(from, to)

    const { data, error: fetchError, count } = await query
    if (fetchError) return jsonError(fetchError.message, 400)

    const total = count ?? 0
    const total_pages = Math.max(1, Math.ceil(total / per_page))
    return NextResponse.json(
      {
        success: true,
        data,
        pagination: { total, page, per_page, total_pages },
      },
      { status: 200 }
    )
  } catch (e: any) {
    return jsonError('Failed to fetch orders', 500)
  }
}
